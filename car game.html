<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Racer: Galactic Challenge</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: linear-gradient(135deg, #0c0e2b, #1a1c4e);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 7, 30, 0.9);
            z-index: 20;
            transition: opacity 0.5s;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            margin-bottom: 1rem;
            text-shadow: 0 0 10px #00f7ff, 0 0 20px #00f7ff;
            letter-spacing: 3px;
            background: linear-gradient(to right, #00f7ff, #a200ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titleGlow 2s infinite alternate;
        }

        .subtitle {
            font-size: 1.5rem;
            margin-bottom: 3rem;
            color: #fbc531;
            text-align: center;
            max-width: 80%;
            line-height: 1.6;
            text-shadow: 0 0 5px rgba(251, 197, 49, 0.5);
        }

        .story {
            background: rgba(0, 0, 0, 0.4);
            padding: 20px;
            border-radius: 10px;
            max-width: 600px;
            margin: 20px auto;
            border: 1px solid rgba(0, 247, 255, 0.3);
            font-size: 1.1rem;
            line-height: 1.6;
        }

        .story h3 {
            color: #00f7ff;
            text-align: center;
            margin-bottom: 10px;
            font-family: 'Orbitron', sans-serif;
        }

        .btn {
            background: linear-gradient(to right, #00c6ff, #0072ff);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            border-radius: 50px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 1px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            font-family: 'Orbitron', sans-serif;
            margin: 10px;
        }

        .btn:hover {
            background: linear-gradient(to right, #0072ff, #00c6ff);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 114, 255, 0.6);
        }

        #countdown-screen {
            background: rgba(5, 7, 30, 0.95);
        }

        #countdown {
            font-size: 10rem;
            font-weight: bold;
            color: #fbc531;
            text-shadow: 0 0 20px rgba(251, 197, 49, 0.8);
            animation: pulse 1s infinite;
        }

        /* Game UI */
        #game-ui {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            display: flex;
            gap: 20px;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .ui-box {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            min-width: 120px;
            border: 1px solid rgba(0, 247, 255, 0.2);
        }

        .ui-title {
            font-size: 0.9rem;
            color: #00f7ff;
            margin-bottom: 5px;
        }

        .ui-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
        }

        #position-display {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            font-size: 1.5rem;
            font-weight: bold;
            color: #fbc531;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        #speed-boost-indicator {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 1.2rem;
            color: #00f7ff;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        #speed-boost-indicator.active {
            opacity: 1;
        }
       
        #boost-storage {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
       
        .boost-item {
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #00f7ff, #0072ff);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px #00f7ff;
            animation: boosterPulse 1.5s infinite;
        }
       
        .boost-item.empty {
            background: #333;
            box-shadow: none;
            animation: none;
            opacity: 0.5;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        /* Finish screen */
        #finish-screen {
            display: none;
        }

        #finish-screen h2 {
            font-size: 4rem;
            color: #fbc531;
            margin-bottom: 2rem;
            text-shadow: 0 0 10px rgba(251, 197, 49, 0.8);
        }

        #finish-position {
            font-size: 5rem;
            margin-bottom: 2rem;
            color: #00f7ff;
            text-shadow: 0 0 15px rgba(0, 247, 255, 0.8);
        }

        #results-table {
            width: 80%;
            max-width: 500px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 2rem;
            border: 1px solid rgba(0, 247, 255, 0.3);
        }

        .result-row {
            display: flex;
            padding: 12px 20px;
            border-bottom: 1px solid rgba(0, 247, 255, 0.1);
        }

        .result-row.header {
            background: rgba(0, 114, 255, 0.6);
            font-weight: bold;
        }

        .result-position {
            width: 20%;
            text-align: center;
        }

        .result-name {
            width: 60%;
        }

        .result-time {
            width: 20%;
            text-align: right;
        }

        /* Game Over Screen */
        #game-over-screen {
            display: none;
        }

        #game-over-title {
            font-size: 6rem;
            color: #e84118;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(232, 65, 24, 0.8);
            font-family: 'Orbitron', sans-serif;
            animation: gameOverPulse 1.5s infinite;
        }

        #game-over-position {
            font-size: 5rem;
            margin-bottom: 2rem;
            color: #fbc531;
            text-shadow: 0 0 15px rgba(251, 197, 49, 0.8);
        }

        #game-over-text {
            font-size: 1.8rem;
            margin-bottom: 3rem;
            color: #00f7ff;
            text-align: center;
            max-width: 80%;
        }

        /* Animations */
        @keyframes titleGlow {
            0% {
                text-shadow: 0 0 10px #00f7ff, 0 0 20px #00f7ff;
            }
            100% {
                text-shadow: 0 0 20px #00f7ff, 0 0 40px #00f7ff, 0 0 60px #a200ff;
            }
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes boosterPulse {
            0% {
                transform: scale(1);
                opacity: 0.7;
            }
            50% {
                transform: scale(1.2);
                opacity: 1;
            }
            100% {
                transform: scale(1);
                opacity: 0.7;
            }
        }

        @keyframes gameOverPulse {
            0% {
                transform: scale(1);
                text-shadow: 0 0 10px #e84118, 0 0 20px #e84118;
            }
            50% {
                transform: scale(1.05);
                text-shadow: 0 0 20px #e84118, 0 0 40px #e84118;
            }
            100% {
                transform: scale(1);
                text-shadow: 0 0 10px #e84118, 0 0 20px #e84118;
            }
        }

        /* Controls hint */
        #controls-hint {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            color: #00f7ff;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        /* Fullscreen button */
        #fullscreen-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            z-index: 30;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
            font-family: 'Orbitron', sans-serif;
        }
       
        /* Boost effect */
        .boost-effect {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,247,255,0.8) 0%, transparent 70%);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transform: scale(0);
            transition: opacity 0.3s, transform 0.5s;
        }
       
        .boost-effect.active {
            opacity: 1;
            transform: scale(1);
        }
       
        /* Sound controls */
        #sound-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 30;
        }
       
        .sound-btn {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 0.9rem;
            border: 1px solid rgba(0, 247, 255, 0.3);
            backdrop-filter: blur(5px);
            font-family: 'Orbitron', sans-serif;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
       
        <div id="ui-layer">
            <!-- Title Screen -->
            <div id="title-screen" class="screen">
                <h1 class="title">Cosmic Racer</h1>
                <p class="subtitle">Galactic Speed Challenge</p>
                <div class="story">
                    <h3>THE YEAR 3025</h3>
                    <p>You're a rookie pilot in the prestigious Nebula Grand Prix. Compete against the galaxy's top racers through treacherous asteroid fields and cosmic anomalies. Collect quantum crystals to boost your ship and prove you have what it takes to be champion!</p>
                    <p>Finish before your opponents or be eliminated when they complete the race!</p>
                </div>
                <button id="start-btn" class="btn">Start Race</button>
            </div>
           
            <!-- Countdown Screen -->
            <div id="countdown-screen" class="screen" style="display: none;">
                <div id="countdown">3</div>
            </div>
           
            <!-- Game UI -->
            <div id="game-ui">
                <div class="ui-box">
                    <div class="ui-title">Speed</div>
                    <div id="speed-value" class="ui-value">0 AU/s</div>
                </div>
                <div class="ui-box">
                    <div class="ui-title">Lap</div>
                    <div id="lap-value" class="ui-value">1/5</div>
                </div>
            </div>
           
            <div id="position-display">1st</div>
           
            <div id="speed-boost-indicator">QUANTUM BOOST ACTIVATED!</div>
           
            <div id="boost-storage">
                <div class="boost-item empty"></div>
                <div class="boost-item empty"></div>
                <div class="boost-item empty"></div>
            </div>
           
            <div id="controls-hint">Controls: Arrow Keys to move, SPACE to use quantum boost</div>
           
            <!-- Finish Screen -->
            <div id="finish-screen" class="screen">
                <h2>Race Finished</h2>
                <div id="finish-position">1st</div>
                <div id="results-table">
                    <div class="result-row header">
                        <div class="result-position">Pos</div>
                        <div class="result-name">Pilot</div>
                        <div class="result-time">Time</div>
                    </div>
                    <!-- Results will be populated by JS -->
                </div>
                <button id="restart-btn" class="btn">Race Again</button>
            </div>
            
            <!-- Game Over Screen -->
            <div id="game-over-screen" class="screen">
                <div id="game-over-title">GAME OVER</div>
                <div id="game-over-position">5th Place</div>
                <div id="game-over-text">All opponents have finished the race!<br>You have been eliminated.</div>
                <button id="game-over-restart-btn" class="btn">Try Again</button>
            </div>
        </div>
       
        <button id="fullscreen-btn">Fullscreen</button>
       
        <!-- Sound controls -->
        <div id="sound-controls">
            <button id="mute-btn" class="sound-btn">Mute</button>
        </div>
       
        <!-- Boost effect element -->
        <div id="boost-effect" class="boost-effect"></div>
    </div>

    <script>
        // Game variables
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const titleScreen = document.getElementById('title-screen');
        const countdownScreen = document.getElementById('countdown-screen');
        const countdownElement = document.getElementById('countdown');
        const finishScreen = document.getElementById('finish-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const gameOverRestartBtn = document.getElementById('game-over-restart-btn');
        const speedValue = document.getElementById('speed-value');
        const lapValue = document.getElementById('lap-value');
        const positionDisplay = document.getElementById('position-display');
        const speedBoostIndicator = document.getElementById('speed-boost-indicator');
        const resultsTable = document.getElementById('results-table');
        const boostStorage = document.getElementById('boost-storage');
        const finishPosition = document.getElementById('finish-position');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const boostEffect = document.getElementById('boost-effect');
        const muteBtn = document.getElementById('mute-btn');
       
        // Set canvas size to window size
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
       
        // Game state
        const gameState = {
            current: 'title', // title, countdown, racing, finished, gameOver
            countdown: 3,
            countdownInterval: null,
            lap: 1,
            maxLaps: 5,
            position: 1,
            raceStarted: false,
            raceFinished: false,
            playerSpeedBoost: 0,
            raceStartTime: 0,
            raceTimes: [],
            carsFinished: 0,
            playerBoosts: 0,
            cameraOffset: 0,
            trackLength: 40000,
            muted: false
        };
       
        // Initialize the game
        function initGame() {
            // Reset game state
            gameState.current = 'countdown';
            gameState.countdown = 3;
            gameState.lap = 1;
            gameState.position = 1;
            gameState.raceStarted = false;
            gameState.raceFinished = false;
            gameState.playerSpeedBoost = 0;
            gameState.raceTimes = [];
            gameState.carsFinished = 0;
            gameState.playerBoosts = 0;
            gameState.cameraOffset = 0;
            gameState.trackLength = 40000;
           
            // Reinitialize game objects
            initGameObjects();
           
            // Update boost storage UI
            updateBoostStorage();
           
            // Hide/show screens
            titleScreen.style.display = 'none';
            countdownScreen.style.display = 'flex';
            finishScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
           
            // Update UI
            lapValue.textContent = `${gameState.lap}/${gameState.maxLaps}`;
            positionDisplay.textContent = '1st';
            speedValue.textContent = '0 AU/s';
            speedBoostIndicator.classList.remove('active');
           
            // Start countdown
            countdownElement.textContent = gameState.countdown;
           
            if (gameState.countdownInterval) {
                clearInterval(gameState.countdownInterval);
            }
           
            gameState.countdownInterval = setInterval(() => {
                gameState.countdown--;
                countdownElement.textContent = gameState.countdown;
               
                if (gameState.countdown <= 0) {
                    clearInterval(gameState.countdownInterval);
                    countdownElement.textContent = 'GO!';
                   
                    setTimeout(() => {
                        countdownScreen.style.display = 'none';
                        gameState.current = 'racing';
                        gameState.raceStarted = true;
                        gameState.raceStartTime = Date.now();
                    }, 1000);
                }
            }, 1000);
        }
       
        // Update boost storage UI
        function updateBoostStorage() {
            const boostItems = boostStorage.querySelectorAll('.boost-item');
            boostItems.forEach((item, index) => {
                if (index < gameState.playerBoosts) {
                    item.classList.remove('empty');
                } else {
                    item.classList.add('empty');
                }
            });
        }
       
        // Toggle mute
        function toggleMute() {
            gameState.muted = !gameState.muted;
            muteBtn.textContent = gameState.muted ? "Unmute" : "Mute";
        }
       
        // Star class for background
        class Star {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.size = Math.random() * 2;
                this.speed = 0.1 + Math.random() * 0.3;
                this.brightness = Math.random();
            }
           
            update() {
                this.y += this.speed;
                if (this.y > canvas.height) {
                    this.y = 0;
                    this.x = Math.random() * canvas.width;
                }
               
                // Twinkle effect
                this.brightness = 0.5 + Math.sin(Date.now()/1000 + this.x) * 0.5;
            }
           
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${this.brightness})`;
                ctx.fill();
            }
        }
       
        // Nebula class for background
        class Nebula {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height * 0.5;
                this.width = 200 + Math.random() * 300;
                this.height = 100 + Math.random() * 150;
                this.color1 = `hsl(${Math.floor(Math.random() * 360)}, 70%, 30%)`;
                this.color2 = `hsl(${Math.floor(Math.random() * 360)}, 70%, 30%)`;
                this.speed = 0.01 + Math.random() * 0.02;
            }
           
            update() {
                this.x += this.speed;
                if (this.x > canvas.width + 300) {
                    this.x = -300;
                    this.y = Math.random() * canvas.height * 0.5;
                }
            }
           
            draw() {
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.width
                );
                gradient.addColorStop(0, this.color1);
                gradient.addColorStop(1, this.color2);
               
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.width, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }
       
        // Spaceship class
        class Spaceship {
            constructor(x, y, width, height, color, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.speed = 0;
                this.maxSpeed = isPlayer ? 8 : 6 + Math.random() * 3;
                this.acceleration = isPlayer ? 0.2 : 0.1 + Math.random() * 0.15;
                this.friction = 0.05;
                this.isPlayer = isPlayer;
                this.aiBehavior = isPlayer ? null : this.getRandomBehavior();
                this.boostTimer = 0;
                this.lap = 1;
                this.position = 0;
                this.name = isPlayer ? "Player" : this.getRandomName();
                this.finished = false;
                this.finishTime = 0;
                this.lane = Math.floor(Math.random() * 3);
                this.targetLane = this.lane;
                this.laneChangeSpeed = 0.05;
                this.offTrackTimer = 0;
                this.hasCrossedFinish = false;
            }
           
            getRandomBehavior() {
                const behaviors = ['aggressive', 'defensive', 'steady', 'erratic'];
                return behaviors[Math.floor(Math.random() * behaviors.length)];
            }
           
            getRandomName() {
                const names = ['Nova Rider', 'Star Chaser', 'Galaxy Runner', 'Comet Blazer'];
                return names[Math.floor(Math.random() * names.length)];
            }
           
            update(road) {
                if (!gameState.raceStarted || this.finished) return;
               
                // Apply friction
                this.speed -= this.friction;
               
                // Cap speed
                if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
                if (this.speed < 0) this.speed = 0;
               
                // Apply boost if active
                if (this.boostTimer > 0) {
                    this.speed = this.maxSpeed * 1.5;
                    this.boostTimer--;
                }
               
                // Move ship forward
                this.y -= this.speed;
               
                // Lane changing logic for AI
                if (!this.isPlayer) {
                    this.aiMove(road);
                   
                    // Smooth lane changing
                    const targetX = road.getLaneCenter(this.targetLane);
                    this.x += (targetX - this.x) * this.laneChangeSpeed;
                }
               
                // Boundary checks
                if (this.x < road.roadX + 20) {
                    this.x = road.roadX + 20;
                    this.offTrackTimer = 30;
                }
                if (this.x > road.roadX + road.roadWidth - this.width - 20) {
                    this.x = road.roadX + road.roadWidth - this.width - 20;
                    this.offTrackTimer = 30;
                }
               
                // Off-track penalty
                if (this.offTrackTimer > 0) {
                    this.speed *= 0.95;
                    this.offTrackTimer--;
                }
               
                // Check for lap completion (finish line at y=0)
                if (this.y <= 0 && !this.hasCrossedFinish) {
                    this.lap++;
                    this.hasCrossedFinish = true;
                   
                    if (this.isPlayer) {
                        gameState.lap = this.lap;
                        lapValue.textContent = `${gameState.lap}/${gameState.maxLaps}`;
                    }
                   
                    if (this.lap > gameState.maxLaps) {
                        this.finished = true;
                        this.finishTime = Date.now() - gameState.raceStartTime;
                        gameState.raceTimes.push({
                            name: this.name,
                            time: this.finishTime,
                            isPlayer: this.isPlayer
                        });
                        gameState.carsFinished++;
                       
                        // Stop the ship and set position to the finish line
                        this.speed = 0;
                        this.y = 0; // Fix position at finish line
                       
                        if (this.isPlayer) {
                            gameState.raceFinished = true;
                        }
                    } else {
                        // Reset for next lap
                        setTimeout(() => {
                            this.hasCrossedFinish = false;
                        }, 1000);
                    }
                }
            }
           
            aiMove(road) {
                // Different behaviors based on AI type
                switch(this.aiBehavior) {
                    case 'aggressive':
                        this.speed += this.acceleration * 1.3;
                        if (Math.random() < 0.02) {
                            this.targetLane = Math.floor(Math.random() * 3);
                        }
                        break;
                    case 'defensive':
                        this.speed += this.acceleration * 0.9;
                        if (Math.random() < 0.01) {
                            this.targetLane = Math.floor(Math.random() * 3);
                        }
                        break;
                    case 'steady':
                        this.speed += this.acceleration;
                        if (Math.random() < 0.015) {
                            this.targetLane = Math.floor(Math.random() * 3);
                        }
                        break;
                    case 'erratic':
                        this.speed += this.acceleration * (0.8 + Math.random() * 0.5);
                        if (Math.random() < 0.03) {
                            this.targetLane = Math.floor(Math.random() * 3);
                        }
                        break;
                }
            }
           
            draw(screenY) {
                ctx.save();
                ctx.translate(this.x, screenY);
               
                // Ship body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(0, -this.height/2);
                ctx.lineTo(-this.width/2, this.height/3);
                ctx.lineTo(-this.width/4, this.height/2);
                ctx.lineTo(this.width/4, this.height/2);
                ctx.lineTo(this.width/2, this.height/3);
                ctx.closePath();
                ctx.fill();
               
                // Ship details
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(0, -this.height/4);
                ctx.lineTo(-this.width/3, this.height/4);
                ctx.lineTo(this.width/3, this.height/4);
                ctx.closePath();
                ctx.fill();
               
                // Cockpit
                ctx.fillStyle = 'rgba(173, 216, 230, 0.7)';
                ctx.beginPath();
                ctx.arc(0, -this.height/8, this.width/6, 0, Math.PI * 2);
                ctx.fill();
               
                // Engine glow
                ctx.fillStyle = `rgba(0, 247, 255, ${0.3 + Math.random() * 0.3})`;
                ctx.beginPath();
                ctx.moveTo(-this.width/4, this.height/2);
                ctx.lineTo(0, this.height/2 + 15);
                ctx.lineTo(this.width/4, this.height/2);
                ctx.closePath();
                ctx.fill();
               
                // Boost effect
                if (this.boostTimer > 0) {
                    ctx.fillStyle = `rgba(0, 200, 255, ${Math.random() * 0.8})`;
                    ctx.beginPath();
                    ctx.moveTo(-this.width/6, this.height/2 + 5);
                    ctx.lineTo(0, this.height/2 + 30 + Math.random() * 20);
                    ctx.lineTo(this.width/6, this.height/2 + 5);
                    ctx.closePath();
                    ctx.fill();
                }
               
                ctx.restore();
            }
           
            activateBoost(duration) {
                this.boostTimer = duration;
                if (this.isPlayer) {
                    speedBoostIndicator.classList.add('active');
                    setTimeout(() => {
                        speedBoostIndicator.classList.remove('active');
                    }, duration * 16);
                   
                    // Visual boost effect
                    boostEffect.style.left = (this.x - 50) + 'px';
                    boostEffect.style.top = (canvas.height * 0.7 - 50) + 'px';
                    boostEffect.classList.add('active');
                    setTimeout(() => {
                        boostEffect.classList.remove('active');
                    }, 500);
                }
            }
        }
       
        // SpaceTrack class for the track
        class SpaceTrack {
            constructor() {
                this.roadWidth = 400;
                this.roadX = canvas.width/2 - this.roadWidth/2;
                this.laneWidth = this.roadWidth / 3;
                this.length = gameState.trackLength;
            }
           
            getLaneCenter(laneIndex) {
                return this.roadX + this.laneWidth * laneIndex + this.laneWidth/2;
            }
           
            draw(cameraOffset) {
                // Draw track base
                ctx.fillStyle = 'rgba(20, 20, 60, 0.8)';
                ctx.fillRect(this.roadX, -cameraOffset, this.roadWidth, this.length);
               
                // Draw track markings (glowing lines)
                ctx.strokeStyle = '#00f7ff';
                ctx.lineWidth = 3;
                ctx.setLineDash([40, 30]);
               
                // Center lines
                for (let y = 0; y < this.length; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(canvas.width/2, y - cameraOffset);
                    ctx.lineTo(canvas.width/2, y - cameraOffset + 50);
                    ctx.stroke();
                }
               
                // Lane markings
                ctx.beginPath();
                ctx.moveTo(this.roadX + this.laneWidth, -cameraOffset);
                ctx.lineTo(this.roadX + this.laneWidth, this.length - cameraOffset);
                ctx.stroke();
               
                ctx.beginPath();
                ctx.moveTo(this.roadX + this.laneWidth * 2, -cameraOffset);
                ctx.lineTo(this.roadX + this.laneWidth * 2, this.length - cameraOffset);
                ctx.stroke();
               
                ctx.setLineDash([]);
               
                // Draw track borders (glowing)
                ctx.strokeStyle = '#00f7ff';
                ctx.lineWidth = 5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00f7ff';
                ctx.beginPath();
                ctx.moveTo(this.roadX, -cameraOffset);
                ctx.lineTo(this.roadX, this.length - cameraOffset);
                ctx.stroke();
               
                ctx.beginPath();
                ctx.moveTo(this.roadX + this.roadWidth, -cameraOffset);
                ctx.lineTo(this.roadX + this.roadWidth, this.length - cameraOffset);
                ctx.stroke();
                ctx.shadowBlur = 0;
               
                // Draw start/finish line at the top (y=0)
                ctx.fillStyle = '#00f7ff';
                for (let i = 0; i < 10; i++) {
                    if (i % 2 === 0) {
                        ctx.fillRect(this.roadX, i * 10 - cameraOffset, this.roadWidth, 10);
                    }
                }
               
                // Draw finish line at the bottom (y=trackLength)
                ctx.fillStyle = '#fbc531';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#fbc531';
                for (let i = 0; i < 10; i++) {
                    if (i % 2 === 0) {
                        ctx.fillRect(this.roadX, this.length - i * 10 - cameraOffset, this.roadWidth, 10);
                    }
                }
                ctx.shadowBlur = 0;
            }
        }
       
        // Planet class for background
        class Planet {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 50 + Math.random() * 100;
                this.color = `hsl(${Math.floor(Math.random() * 360)}, 70%, 50%)`;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.01;
            }
           
            draw(cameraOffset) {
                const screenY = this.y - cameraOffset;
                if (screenY < -this.radius*2 || screenY > canvas.height + this.radius*2) return;
               
                ctx.save();
                ctx.translate(this.x, screenY);
                ctx.rotate(this.rotation);
               
                // Planet glow
                ctx.shadowBlur = 30;
                ctx.shadowColor = this.color;
               
                // Planet body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
               
                // Planet details
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(this.radius/3, -this.radius/3, this.radius/4, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.beginPath();
                ctx.arc(-this.radius/2, this.radius/3, this.radius/3, 0, Math.PI * 2);
                ctx.fill();
               
                ctx.restore();
                ctx.shadowBlur = 0;
               
                // Update rotation
                this.rotation += this.rotationSpeed;
            }
        }
       
        // Energy Crystal class
        class EnergyCrystal {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.active = true;
                this.respawnTimer = 0;
            }
           
            update() {
                if (!this.active) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.active = true;
                    }
                }
            }
           
            draw(cameraOffset) {
                if (!this.active) return;
               
                const screenY = this.y - cameraOffset;
                if (screenY < -50 || screenY > canvas.height + 50) return;
               
                ctx.save();
                ctx.translate(this.x, screenY);
               
                // Crystal glow
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00f7ff';
               
                // Crystal body
                ctx.fillStyle = '#00f7ff';
                ctx.beginPath();
                ctx.moveTo(0, -this.height/2);
                ctx.lineTo(-this.width/2, 0);
                ctx.lineTo(0, this.height/2);
                ctx.lineTo(this.width/2, 0);
                ctx.closePath();
                ctx.fill();
               
                // Inner glow
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.moveTo(0, -this.height/4);
                ctx.lineTo(-this.width/4, 0);
                ctx.lineTo(0, this.height/4);
                ctx.lineTo(this.width/4, 0);
                ctx.closePath();
                ctx.fill();
               
                ctx.restore();
                ctx.shadowBlur = 0;
            }
           
            checkCollision(ship, cameraOffset) {
                if (!this.active) return false;
               
                const distance = Math.sqrt(
                    Math.pow(ship.x - this.x, 2) +
                    Math.pow((ship.y - cameraOffset) - (this.y - cameraOffset), 2)
                );
               
                if (distance < (ship.width/2 + this.width/2)) {
                    this.active = false;
                    this.respawnTimer = 300; // 5 seconds at 60fps
                    return true;
                }
               
                return false;
            }
        }

        // Game objects
        let track, playerShip, aiShips, crystals, planets, stars, nebulae;
       
        // Initialize game objects
        function initGameObjects() {
            // Create space track
            track = new SpaceTrack();
           
            // Create player and AI ships at starting positions
            playerShip = new Spaceship(track.getLaneCenter(1), track.length - 500, 40, 70, '#00f7ff', true);
           
            aiShips = [];
            const colors = ['#ff00aa', '#fbc531', '#4cd137', '#ff5500'];
            for (let i = 0; i < 4; i++) {
                aiShips.push(new Spaceship(
                    track.getLaneCenter(i % 3),
                    track.length - 600 - i * 50,
                    40, 70,
                    colors[i],
                    false
                ));
            }
           
            // Create energy crystals on the track
            crystals = [];
            for (let i = 0; i < 200; i++) {
                crystals.push(new EnergyCrystal(
                    track.roadX + 50 + Math.random() * (track.roadWidth - 100),
                    track.length - 300 - i * 200
                ));
            }
           
            // Create planets in background
            planets = [];
            for (let i = 0; i < 10; i++) {
                planets.push(new Planet(
                    Math.random() < 0.5 ? 
                        50 + Math.random() * 100 : 
                        canvas.width - 150 - Math.random() * 100,
                    i * 800
                ));
            }
           
            // Create stars
            stars = [];
            for (let i = 0; i < 200; i++) {
                stars.push(new Star());
            }
           
            // Create nebulae
            nebulae = [];
            for (let i = 0; i < 5; i++) {
                nebulae.push(new Nebula());
            }
        }
       
        // Initialize game objects at start
        initGameObjects();
       
        // Key controls
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            ' ': false // Spacebar for boost
        };
       
        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
        });
       
        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
        });
       
        // Button event listeners
        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        gameOverRestartBtn.addEventListener('click', initGame);
        muteBtn.addEventListener('click', toggleMute);
       
        // Fullscreen button
        fullscreenBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                document.exitFullscreen();
            }
        });
       
        // Show results
        function showResults() {
            // Sort by finish time
            gameState.raceTimes.sort((a, b) => a.time - b.time);
           
            // Clear existing results (except header)
            const rows = resultsTable.querySelectorAll('.result-row:not(.header)');
            rows.forEach(row => row.remove());
           
            // Add results
            gameState.raceTimes.forEach((ship, index) => {
                const row = document.createElement('div');
                row.className = 'result-row';
                row.innerHTML = `
                    <div class="result-position">${index+1}${index === 0 ? 'st' : index === 1 ? 'nd' : index === 2 ? 'rd' : 'th'}</div>
                    <div class="result-name">${ship.name}</div>
                    <div class="result-time">${formatTime(ship.time)}</div>
                `;
                if (ship.isPlayer) {
                    row.style.background = 'rgba(0, 247, 255, 0.2)';
                    finishPosition.textContent = `${index+1}${index === 0 ? 'st' : index === 1 ? 'nd' : index === 2 ? 'rd' : 'th'}`;
                }
                resultsTable.appendChild(row);
            });
           
            finishScreen.style.display = 'flex';
        }
       
        // Format time as mm:ss:ms or DNF
        function formatTime(ms) {
            if (ms === null) return "DNF";
            
            const totalSeconds = ms / 1000;
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = Math.floor(totalSeconds % 60);
            const milliseconds = Math.floor((ms % 1000) / 10);
           
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(2, '0')}`;
        }
       
        // Check if all AI ships have finished
        function allAIFinished() {
            for (let ship of aiShips) {
                if (!ship.finished) return false;
            }
            return true;
        }
       
        // Show game over screen
        function showGameOver() {
            gameState.current = 'gameOver';
            gameOverScreen.style.display = 'flex';
        }
       
        // Game loop
        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
           
            // Update camera to follow player
            let targetOffset = playerShip.y - canvas.height * 0.7;
            // Don't let camera go above the start (y=0) of the track
            if (targetOffset < 0) {
                targetOffset = 0;
            }
            gameState.cameraOffset = targetOffset;
           
            // Draw space background
            ctx.fillStyle = '#0c0e2b';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
           
            // Draw nebulae
            nebulae.forEach(nebula => {
                nebula.update();
                nebula.draw();
            });
           
            // Draw stars
            stars.forEach(star => {
                star.update();
                star.draw();
            });
           
            // Draw planets
            planets.forEach(planet => {
                planet.draw(gameState.cameraOffset);
            });
           
            // Draw track
            track.draw(gameState.cameraOffset);
           
            // Draw crystals
            crystals.forEach(crystal => {
                crystal.update();
                crystal.draw(gameState.cameraOffset);
            });
           
            // Update and draw player ship
            if (gameState.current === 'racing' && !playerShip.finished) {
                // Player controls
                if (keys.ArrowUp) playerShip.speed += playerShip.acceleration;
                if (keys.ArrowDown) playerShip.speed -= playerShip.acceleration;
               
                if (keys.ArrowLeft) playerShip.x -= 5;
                if (keys.ArrowRight) playerShip.x += 5;
               
                // Use stored boost
                if (keys[' '] && gameState.playerBoosts > 0 && !playerShip.finished) {
                    playerShip.activateBoost(150);
                    gameState.playerBoosts--;
                    updateBoostStorage();
                    keys[' '] = false; // Prevent continuous activation
                }
               
                // Update speed display
                speedValue.textContent = Math.round(playerShip.speed * 20) + ' AU/s';
            }
           
            playerShip.update(track);
            playerShip.draw(playerShip.y - gameState.cameraOffset);
           
            // Update and draw AI ships
            aiShips.forEach(ship => {
                ship.update(track);
                ship.draw(ship.y - gameState.cameraOffset);
               
                // Check crystal collision for AI ships
                if (!ship.finished) {
                    crystals.forEach(crystal => {
                        if (crystal.checkCollision(ship, gameState.cameraOffset)) {
                            ship.activateBoost(100);
                        }
                    });
                }
            });
           
            // Check crystal collision for player
            if (!playerShip.finished) {
                crystals.forEach(crystal => {
                    if (crystal.checkCollision(playerShip, gameState.cameraOffset)) {
                        if (gameState.playerBoosts < 3) {
                            gameState.playerBoosts++;
                            updateBoostStorage();
                        }
                    }
                });
            }
           
            // Calculate player position
            let playerPosition = 1;
            aiShips.forEach(ship => {
                if (ship.y < playerShip.y && !ship.finished && !playerShip.finished) playerPosition++;
            });
           
            gameState.position = playerPosition;
            const positionText =
                playerPosition === 1 ? '1st' :
                playerPosition === 2 ? '2nd' :
                playerPosition === 3 ? '3rd' :
                playerPosition + 'th';
            positionDisplay.textContent = positionText;
           
            // Check if all AI ships have finished and player hasn't
            if (allAIFinished() && !playerShip.finished && !gameState.raceFinished) {
                playerShip.finished = true;
                gameState.raceFinished = true;
                gameState.raceTimes.push({
                    name: playerShip.name,
                    time: null, // Player didn't finish
                    isPlayer: true
                });
                gameState.carsFinished++;
                showGameOver();
            }
           
            requestAnimationFrame(animate);
        }
       
        // Start the animation
        animate();
    </script>
</body>
</html>